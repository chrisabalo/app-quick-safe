{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _this = this,\n  _jsxFileName = \"E:\\\\local\\\\app-quick-safe\\\\node_modules\\\\react-native-maps\\\\lib\\\\components\\\\Geojson.js\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React from 'react';\nimport Marker from \"./MapMarker\";\nimport Polyline from \"./MapPolyline\";\nimport Polygon from \"./MapPolygon\";\nexport var makeOverlays = function makeOverlays(features) {\n  var points = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n  var lines = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n  var multipolygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'MultiPolygon';\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []);\n  var polygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'Polygon';\n  }).map(function (feature) {\n    return makeOverlay(makeCoordinates(feature), feature);\n  }).reduce(flatten, []).concat(multipolygons).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return points.concat(lines).concat(polygons);\n};\nvar flatten = function flatten(prev, curr) {\n  return prev.concat(curr);\n};\nvar makeOverlay = function makeOverlay(coordinates, feature) {\n  var overlay = {\n    feature: feature\n  };\n  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\nvar makeCoordinates = function makeCoordinates(feature) {\n  var g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(function (p) {\n      return p.map(makeLine);\n    });\n  } else {\n    return [];\n  }\n};\nvar doesOverlayContainProperty = function doesOverlayContainProperty(overlay, property) {\n  return overlay.feature && overlay.feature.properties && overlay.feature.properties[property];\n};\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var _hex$match$map = hex.match(/\\w\\w/g).map(function (x) {\n      return parseInt(x, 16);\n    }),\n    _hex$match$map2 = _slicedToArray(_hex$match$map, 3),\n    r = _hex$match$map2[0],\n    g = _hex$match$map2[1],\n    b = _hex$match$map2[2];\n  return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + alpha + \")\";\n};\nvar getColor = function getColor(props, overlay, colorType, overrideColorProp) {\n  if (props.hasOwnProperty(overrideColorProp)) {\n    return props[overrideColorProp];\n  }\n  if (doesOverlayContainProperty(overlay, colorType)) {\n    var color = overlay.feature.properties[colorType];\n    var opacityProperty = colorType + '-opacity';\n    if (doesOverlayContainProperty(overlay, opacityProperty) && color[0] === '#') {\n      color = getRgbaFromHex(color, overlay.feature.properties[opacityProperty]);\n    }\n    return color;\n  }\n  return null;\n};\nvar getStrokeWidth = function getStrokeWidth(props, overlay) {\n  if (props.hasOwnProperty('strokeWidth')) {\n    return props['strokeWidth'];\n  }\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\n    return overlay.feature.properties['stroke-width'];\n  }\n  return null;\n};\nvar Geojson = function Geojson(props) {\n  var overlays = makeOverlays(props.geojson.features);\n  return React.createElement(React.Fragment, {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 148,\n      columnNumber: 5\n    }\n  }, overlays.map(function (overlay, index) {\n    var fillColor = getColor(props, overlay, 'fill', 'fillColor');\n    var strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\n    var markerColor = getColor(props, overlay, 'marker-color', 'color');\n    var strokeWidth = getStrokeWidth(props, overlay);\n    if (overlay.type === 'point') {\n      return React.createElement(Marker, {\n        key: index,\n        coordinate: overlay.coordinates,\n        image: props.image,\n        pinColor: markerColor,\n        zIndex: props.zIndex,\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 156,\n          columnNumber: 13\n        }\n      });\n    }\n    if (overlay.type === 'polygon') {\n      return React.createElement(Polygon, {\n        key: index,\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: strokeColor,\n        fillColor: fillColor,\n        strokeWidth: strokeWidth,\n        tappable: props.tappable,\n        onPress: props.onPress,\n        zIndex: props.zIndex,\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 167,\n          columnNumber: 13\n        }\n      });\n    }\n    if (overlay.type === 'polyline') {\n      return React.createElement(Polyline, {\n        key: index,\n        coordinates: overlay.coordinates,\n        strokeColor: strokeColor,\n        strokeWidth: strokeWidth,\n        lineDashPhase: props.lineDashPhase,\n        lineDashPattern: props.lineDashPattern,\n        lineCap: props.lineCap,\n        lineJoin: props.lineJoin,\n        miterLimit: props.miterLimit,\n        zIndex: props.zIndex,\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 13\n        }\n      });\n    }\n  }));\n};\nexport default Geojson;","map":{"version":3,"names":["React","Marker","Polyline","Polygon","makeOverlays","features","points","filter","f","geometry","type","map","feature","makeCoordinates","coordinates","makeOverlay","reduce","flatten","overlay","lines","multipolygons","polygons","concat","prev","curr","length","holes","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","doesOverlayContainProperty","property","properties","getRgbaFromHex","hex","alpha","match","x","parseInt","r","b","getColor","props","colorType","overrideColorProp","hasOwnProperty","color","opacityProperty","getStrokeWidth","Geojson","overlays","geojson","index","fillColor","strokeColor","markerColor","strokeWidth","image","zIndex","tappable","onPress","lineDashPhase","lineDashPattern","lineCap","lineJoin","miterLimit"],"sources":["E:/local/app-quick-safe/node_modules/react-native-maps/lib/components/Geojson.js"],"sourcesContent":["import React from 'react';\nimport Marker from './MapMarker';\nimport Polyline from './MapPolyline';\nimport Polygon from './MapPolygon';\n\nexport const makeOverlays = features => {\n  const points = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'point' }));\n\n  const lines = features\n    .filter(\n      f =>\n        f.geometry &&\n        (f.geometry.type === 'LineString' ||\n          f.geometry.type === 'MultiLineString')\n    )\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map(overlay => ({ ...overlay, type: 'polyline' }));\n\n  const multipolygons = features\n    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')\n    .map(feature =>\n      makeCoordinates(feature).map(coordinates =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, []);\n\n  const polygons = features\n    .filter(f => f.geometry && f.geometry.type === 'Polygon')\n    .map(feature => makeOverlay(makeCoordinates(feature), feature))\n    .reduce(flatten, [])\n    .concat(multipolygons)\n    .map(overlay => ({ ...overlay, type: 'polygon' }));\n\n  return points.concat(lines).concat(polygons);\n};\n\nconst flatten = (prev, curr) => prev.concat(curr);\n\nconst makeOverlay = (coordinates, feature) => {\n  let overlay = {\n    feature,\n  };\n  if (\n    feature.geometry.type === 'Polygon' ||\n    feature.geometry.type === 'MultiPolygon'\n  ) {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\n\nconst makePoint = c => ({ latitude: c[1], longitude: c[0] });\n\nconst makeLine = l => l.map(makePoint);\n\nconst makeCoordinates = feature => {\n  const g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(p => p.map(makeLine));\n  } else {\n    return [];\n  }\n};\n\nconst doesOverlayContainProperty = (overlay, property) => {\n  // Geojson may have 0 for the opacity when intention is to not specify the\n  // opacity. Therefore, we evaluate the truthiness of the propery where 0\n  // would return false.\n  return (\n    overlay.feature &&\n    overlay.feature.properties &&\n    overlay.feature.properties[property]\n  );\n};\n\nconst getRgbaFromHex = (hex, alpha = 1) => {\n  const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16));\n  return `rgba(${r},${g},${b},${alpha})`;\n};\n\nconst getColor = (props, overlay, colorType, overrideColorProp) => {\n  if (props.hasOwnProperty(overrideColorProp)) {\n    return props[overrideColorProp];\n  }\n  if (doesOverlayContainProperty(overlay, colorType)) {\n    let color = overlay.feature.properties[colorType];\n    const opacityProperty = colorType + '-opacity';\n    if (\n      doesOverlayContainProperty(overlay, opacityProperty) &&\n      color[0] === '#'\n    ) {\n      color = getRgbaFromHex(\n        color,\n        overlay.feature.properties[opacityProperty]\n      );\n    }\n    return color;\n  }\n  return null;\n};\n\nconst getStrokeWidth = (props, overlay) => {\n  if (props.hasOwnProperty('strokeWidth')) {\n    return props['strokeWidth'];\n  }\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\n    return overlay.feature.properties['stroke-width'];\n  }\n  return null;\n};\n\nconst Geojson = props => {\n  const overlays = makeOverlays(props.geojson.features);\n  return (\n    <React.Fragment>\n      {overlays.map((overlay, index) => {\n        const fillColor = getColor(props, overlay, 'fill', 'fillColor');\n        const strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\n        const markerColor = getColor(props, overlay, 'marker-color', 'color');\n        const strokeWidth = getStrokeWidth(props, overlay);\n        if (overlay.type === 'point') {\n          return (\n            <Marker\n              key={index}\n              coordinate={overlay.coordinates}\n              image={props.image}\n              pinColor={markerColor}\n              zIndex={props.zIndex}\n            />\n          );\n        }\n        if (overlay.type === 'polygon') {\n          return (\n            <Polygon\n              key={index}\n              coordinates={overlay.coordinates}\n              holes={overlay.holes}\n              strokeColor={strokeColor}\n              fillColor={fillColor}\n              strokeWidth={strokeWidth}\n              tappable={props.tappable}\n              onPress={props.onPress}\n              zIndex={props.zIndex}\n            />\n          );\n        }\n        if (overlay.type === 'polyline') {\n          return (\n            <Polyline\n              key={index}\n              coordinates={overlay.coordinates}\n              strokeColor={strokeColor}\n              strokeWidth={strokeWidth}\n              lineDashPhase={props.lineDashPhase}\n              lineDashPattern={props.lineDashPattern}\n              lineCap={props.lineCap}\n              lineJoin={props.lineJoin}\n              miterLimit={props.miterLimit}\n              zIndex={props.zIndex}\n            />\n          );\n        }\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default Geojson;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}